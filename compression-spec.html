<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>HPACK</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";3
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Overview"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Outline"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Header Encoding"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Encoding Concepts"/>
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Encoding Context"/>
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Header Table"/>
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 Reference Set"/>
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 Header set"/>
<link href="#rfc.section.3.1.5" rel="Chapter" title="3.1.5 Header Representation"/>
<link href="#rfc.section.3.1.6" rel="Chapter" title="3.1.6 Header Emission"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Header Set Processing"/>
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Header Representation Processing"/>
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Reference Set Emission"/>
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Header Table Management"/>
<link href="#rfc.section.3.2.4" rel="Chapter" title="3.2.4 Specific Use Cases"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Detailed Format"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Low-level representations"/>
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Integer representation"/>
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 String Literal Representation"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Indexed Header Representation"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Literal Header Representation"/>
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Literal Header without Indexing"/>
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Literal Header with Incremental Indexing"/>
<link href="#rfc.section.4.3.3" rel="Chapter" title="4.3.3 Literal Header with Substitution Indexing"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Parameter Negotiation"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations"/>
<link href="#rfc.references" rel="Chapter" title="8 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Change Log (to be removed by RFC Editor before publication"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Since draft-ietf-httpbis-header-compression-01"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Initial Header Tables"/>
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Requests"/>
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Responses"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Example"/>
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 First header set"/>
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Second header set"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.4.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Peon, R. and H. Ruellan" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-httpbis-header-compression-01" />
  <meta name="dct.issued" scheme="ISO8601" content="2013-7" />
  <meta name="dct.abstract" content="This document describes HPACK, a format adapted to efficiently represent HTTP headers in the context of HTTP/2.0.  " />
  <meta name="description" content="This document describes HPACK, a format adapted to efficiently represent HTTP headers in the context of HTTP/2.0.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">HTTPbis Working Group</td>
  <td class="right">R. Peon</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Google, Inc</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">H. Ruellan</td>
</tr>
<tr>
  <td class="left">Expires: January 02, 2014</td>
  <td class="right">Canon CRF</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">July 2013</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">HPACK<br />
  <span class="filename">draft-ietf-httpbis-header-compression-01</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes HPACK, a format adapted to efficiently represent HTTP headers in the context of HTTP/2.0.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 02, 2014.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2013 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Overview</a></li>
<li>2.1.   <a href="#rfc.section.2.1">Outline</a></li>
<li>3.   <a href="#rfc.section.3">Header Encoding</a></li>
<li>3.1.   <a href="#rfc.section.3.1">Encoding Concepts</a></li>
<li>3.1.1.   <a href="#rfc.section.3.1.1">Encoding Context</a></li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Header Table</a></li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">Reference Set</a></li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">Header set</a></li>
<li>3.1.5.   <a href="#rfc.section.3.1.5">Header Representation</a></li>
<li>3.1.6.   <a href="#rfc.section.3.1.6">Header Emission</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Header Set Processing</a></li>
<li>3.2.1.   <a href="#rfc.section.3.2.1">Header Representation Processing</a></li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Reference Set Emission</a></li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">Header Table Management</a></li>
<li>3.2.4.   <a href="#rfc.section.3.2.4">Specific Use Cases</a></li>
<li>4.   <a href="#rfc.section.4">Detailed Format</a></li>
<li>4.1.   <a href="#rfc.section.4.1">Low-level representations</a></li>
<li>4.1.1.   <a href="#rfc.section.4.1.1">Integer representation</a></li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">String Literal Representation</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Indexed Header Representation</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Literal Header Representation</a></li>
<li>4.3.1.   <a href="#rfc.section.4.3.1">Literal Header without Indexing</a></li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Literal Header with Incremental Indexing</a></li>
<li>4.3.3.   <a href="#rfc.section.4.3.3">Literal Header with Substitution Indexing</a></li>
<li>5.   <a href="#rfc.section.5">Parameter Negotiation</a></li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a></li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a></li>
<li>8.   <a href="#rfc.references">Informative References</a></li>
<li>Appendix A.   <a href="#rfc.appendix.A">Change Log (to be removed by RFC Editor before publication</a></li>
<li>A.1.   <a href="#rfc.appendix.A.1">Since draft-ietf-httpbis-header-compression-01</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Initial Header Tables</a></li>
<li>B.1.   <a href="#rfc.appendix.B.1">Requests</a></li>
<li>B.2.   <a href="#rfc.appendix.B.2">Responses</a></li>
<li>Appendix C.   <a href="#rfc.appendix.C">Example</a></li>
<li>C.1.   <a href="#rfc.appendix.C.1">First header set</a></li>
<li>C.2.   <a href="#rfc.appendix.C.2">Second header set</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">This document describes HPACK, a format adapted to efficiently represent HTTP headers in the context of HTTP/2.0.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#overview" id="overview">Overview</a></h1>
<p id="rfc.section.2.p.1">In HTTP/1.X, HTTP headers, which are necessary for the functioning of the protocol, are transmitted with no transformations. Unfortunately, the amount of redundancy in both the keys and the values of these headers is high, and is the cause of increased latency on lower bandwidth links. This indicates that an alternate more compact encoding for headers would be beneficial to latency, and that is what is proposed here.  </p>
<p id="rfc.section.2.p.2">As shown by <a href="#SPDY">SPDY</a> <cite title="NONE">[SPDY]</cite>, Deflate compresses HTTP very effectively. However, the use of a compression scheme which allows for arbitrary matches against the previously encoded data (such as Deflate) exposes users to security issues.  In particular, the compression of sensitive data, together with other data controlled by an attacker, may lead to leakage of that sensitive data, even when the resultant bytes are transmitted over an encrypted channel.  </p>
<p id="rfc.section.2.p.3">Another consideration is that processing and memory costs of a compressor such as Deflate may also be too high for some classes of devices, for example when doing forward or reverse proxying.  </p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> Outline</h1>
<p id="rfc.section.2.1.p.1">The HTTP header encoding described in this document is based on a header table that map (name, value) pairs to index values.  This scheme is believed to be safe for all known attacks against the compression context today.  Header tables are incrementally updated during the HTTP/2.0 session.  </p>
<p id="rfc.section.2.1.p.2">The encoder is responsible for deciding which headers to insert as new entries in the header table.  The decoder then does exactly what the encoder prescribes, ending in a state that exactly matches the encoder's state.  This enables decoders to remain simple and understand a wide variety of encoders.  </p>
<p id="rfc.section.2.1.p.3">As two consecutive sets of headers often have headers in common, each set of headers is coded as a difference from the previous set of headers. The goal is to only encode the changes (headers present in one of the set and not in the other) between the two sets of headers.  </p>
<p id="rfc.section.2.1.p.4">An example illustrating the use of these different mechanisms to represent headers is available in <a href="#example">Appendix C</a>.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#header.encoding" id="header.encoding">Header Encoding</a></h1>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#encoding.concepts" id="encoding.concepts">Encoding Concepts</a></h1>
<p id="rfc.section.3.1.p.1">The encoding and decoding of headers relies on some components and concepts. The set of components used form an encoding context.  </p>

<dl>
  <dt>Header Table:</dt>
  <dd style="margin-left: 8">The header table (see <a href="#header.table">Section 3.1.2</a>) is a component used to associate headers to index values.  </dd>
  <dt>Reference Set:</dt>
  <dd style="margin-left: 8">The reference set (see <a href="#reference.set">Section 3.1.3</a>) is a component containing a group of headers used as a reference for the differential encoding of a new set of headers.  </dd>
  <dt>Header Set:</dt>
  <dd style="margin-left: 8">A header set (see <a href="#header.set">Section 3.1.4</a>) is a group of headers that are encoded jointly. A header set usually consists of all the headers contained in an HTTP request or an HTTP response.  </dd>
  <dt>Header Representation:</dt>
  <dd style="margin-left: 8">A header can be represented in encoded form either as a literal or as an index (see <a href="#header.representation">Section 3.1.5</a>). The indexed representation is based on the header table.  </dd>
  <dt>Header Emission:</dt>
  <dd style="margin-left: 8">When decoding a set of headers, some operations emit a header (see <a href="#header.emission">Section 3.1.6</a>). An emitted header is added to the set of headers. Once emitted, a header can't be removed from the set of headers.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#encoding.context" id="encoding.context">Encoding Context</a></h1>
<p id="rfc.section.3.1.1.p.1">The set of components used to encode or decode a header set form an encoding context: an encoding context contains a header table and a reference set.  </p>
<p id="rfc.section.3.1.1.p.2">Using HTTP, messages are exchanged between a client and a server in both direction. To keep the encoding of headers in each direction independent from the other direction, there is one encoding context for each direction.  </p>
<p id="rfc.section.3.1.1.p.3">The headers contained in a PUSH_PROMISE frame sent by a server to a client are encoded within the same context as the headers contained in the HEADERS frame corresponding to a response sent from the server to the client.  </p>
<h1 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#header.table" id="header.table">Header Table</a></h1>
<p id="rfc.section.3.1.2.p.1">A header table consists of an ordered list of (name, value) pairs. The first entry of a header table is assigned the index 0.  </p>
<p id="rfc.section.3.1.2.p.2">A header can be represented by an entry of the header table if they match. A header and an entry match if both their name and their value match. A header name and an entry name match if they are equal using a character-based, <em>case insensitive</em> comparison (the case insensitive comparison is used because HTTP header names are defined in a case insensitive way). A header value and an entry value match if they are equal using a character-based, <em>case sensitive</em> comparison.  </p>
<p id="rfc.section.3.1.2.p.3">Generally, the header table will not contain duplicate entries. However, implementations MUST be prepared to accept duplicates without signalling an error. If duplicates are added to the table, they MUST be treated as distinct entries with their own index positions.  </p>
<p id="rfc.section.3.1.2.p.4">Initially, a header table contains a list of common headers. Two initial lists of header are provided in <a href="#initial.headers">Appendix B</a>. One list is for headers transmitted from a client to a server, the other for the reverse direction.  </p>
<p id="rfc.section.3.1.2.p.5">A header table is modified by either adding a new entry at the end of the table, or by replacing an existing entry.  </p>
<p id="rfc.section.3.1.2.p.6">The encoder decides how to update the header table and as such can control how much memory is used by the header table. To limit the memory requirements on the decoder side, the header table size is bounded (see the SETTINGS_MAX_BUFFER_SIZE in <a href="#parameter.negotiation">Section 5</a>).  </p>
<p id="rfc.section.3.1.2.p.7">The size of an entry is the sum of its name's length in bytes (as defined in <a href="#string.literal.representation">Section 4.1.2</a>), of its value's length in bytes and of 32 bytes. The 32 bytes are an accounting for the entry structure overhead.  For example, an entry structure using two 64-bits pointers to reference the name and the value and the entry, and two 64-bits integer for counting the number of references to these name and value would use these 32 bytes.  </p>
<p id="rfc.section.3.1.2.p.8">The size of a header table is the sum of the size of its entries.  </p>
<h1 id="rfc.section.3.1.3"><a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#reference.set" id="reference.set">Reference Set</a></h1>
<p id="rfc.section.3.1.3.p.1">A reference set is defined as an unordered set of references to entries of the header table.  </p>
<p id="rfc.section.3.1.3.p.2">The initial reference set is the empty set.  </p>
<p id="rfc.section.3.1.3.p.3">The reference set is updated during the processing of a set of headers.  </p>
<p id="rfc.section.3.1.3.p.4">Using the differential encoding, a header that is not present in the reference set can be encoded either with an indexed representation (if the header is present in the header table), or with a literal representation (if the header is not present in the header table).  </p>
<p id="rfc.section.3.1.3.p.5">A header that is to be removed from the reference set is encoded with an indexed representation.  </p>
<h1 id="rfc.section.3.1.4"><a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#header.set" id="header.set">Header set</a></h1>
<p id="rfc.section.3.1.4.p.1">A header set is a group of header fields that are encoded as a whole. Each header field is a (name, value) pair.  </p>
<p id="rfc.section.3.1.4.p.2">A header set is encoded using an ordered list of zero or more header representations. All the header representations describing a header set a grouped into a header block.  </p>
<h1 id="rfc.section.3.1.5"><a href="#rfc.section.3.1.5">3.1.5.</a> <a href="#header.representation" id="header.representation">Header Representation</a></h1>
<p id="rfc.section.3.1.5.p.1">A header can be represented either as a literal or as an index.  </p>
<p/>

<dl>
  <dt>Literal Representation:</dt>
  <dd style="margin-left: 8">A literal representation defines a new header. The header name is represented either literally or as a reference to an entry of the header table. The header value is represented literally.  </dd>
  <dt></dt>
  <dd style="margin-left: 8">Three different literal representations are provided: <ul><li>A literal representation that does not add the header to the header table (see <a href="#literal.header.without.indexing">Section 4.3.1</a>).  </li><li>A literal representation that adds the header at the end of the header table (see <a href="#literal.header.with.incremental.indexing">Section 4.3.2</a>).  </li><li>A literal representation that uses the header to replace an existing entry of the header table (see <a href="#literal.header.with.substitution.indexing">Section 4.3.3</a>).  </li></ul><p> </p></dd>
  <dt>Indexed Representation:</dt>
  <dd style="margin-left: 8">The indexed representation defines a header as a reference in the header table (see <a href="#indexed.header.representation">Section 4.2</a>).  </dd>
</dl>
<h1 id="rfc.section.3.1.6"><a href="#rfc.section.3.1.6">3.1.6.</a> <a href="#header.emission" id="header.emission">Header Emission</a></h1>
<p id="rfc.section.3.1.6.p.1">The emission of header is the process of adding a header to the current set of headers. Once an header is emitted, it can't be removed from the current set of headers.  </p>
<p id="rfc.section.3.1.6.p.2">The concept of header emission allows a decoder to know when it can pass a header safely to a higher level on the receiver side. This allows a decoder to be implemented in a streaming way, and as such to only keep in memory the header table and the reference set.  With such an implementation, the amount of memory used by the decoder is bounded, even in presence of a very large set of headers. The management of memory for handling very large sets of headers can therefore be deferred to the application.  </p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#header.set.processing" id="header.set.processing">Header Set Processing</a></h1>
<p id="rfc.section.3.2.p.1">The processing of an encoded header set to obtain a list of headers is defined in this section.  To ensure a correct decoding of a header set, a decoder MUST obey the following rules.  </p>
<h1 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#header.representation.processing" id="header.representation.processing">Header Representation Processing</a></h1>
<p id="rfc.section.3.2.1.p.1">All the header representations contained in a header block are processed in their occurring order, as specified below.  </p>
<p id="rfc.section.3.2.1.p.2">An <em>indexed representation</em> corresponding to an entry <em>not present</em> in the reference set entails the following actions: </p>

<ul>
  <li>The header corresponding to the entry is emitted.</li>
  <li>The entry is added to the reference set.</li>
</ul>

<p> </p>
<p id="rfc.section.3.2.1.p.3">An <em>indexed representation</em> corresponding to an entry <em>present</em> in the reference set entails the following actions: </p>

<ul>
  <li>The entry is removed from the reference set.</li>
</ul>

<p> </p>
<p id="rfc.section.3.2.1.p.4">A <em>literal representation</em> that is <em>not added</em> to the header table entails the following action: </p>

<ul>
  <li>The header is emitted.</li>
</ul>

<p> </p>
<p id="rfc.section.3.2.1.p.5">A <em>literal representation</em> that is <em>added</em> to the header table entails the following actions: </p>

<ul>
  <li>The header is emitted.</li>
  <li>The header is added to the header table, at the location defined by the representation.</li>
  <li>The new entry is added to the reference set.</li>
</ul>

<p> </p>
<h1 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#reference.set.emission" id="reference.set.emission">Reference Set Emission</a></h1>
<p id="rfc.section.3.2.2.p.1">Once all the representations contained in a header block have been processed, the headers that are in common with the previous header set are emitted, during the reference set emission.  </p>
<p id="rfc.section.3.2.2.p.2">For the reference set emission, each header contained in the reference set that has not been emitted during the processing of the header block is emitted.  </p>
<h1 id="rfc.section.3.2.3"><a href="#rfc.section.3.2.3">3.2.3.</a> <a href="#header.table.management" id="header.table.management">Header Table Management</a></h1>
<p id="rfc.section.3.2.3.p.1">The header table can be modified by either adding a new entry to it or by replacing an existing one.  Before doing such a modification, it has to be ensured that the header table size will stay lower than or equal to the SETTINGS_MAX_BUFFER_SIZE limit (see <a href="#parameter.negotiation">Section 5</a>).  To achieve this, repeatedly, the first entry of the header table is removed, until enough space is available for the modification.  </p>
<p id="rfc.section.3.2.3.p.2">A consequence of removing one or more entries at the beginning of the header table is that the remaining entries are renumbered. The first entry of the header table is always associated to the index 0.  </p>
<p id="rfc.section.3.2.3.p.3">When the modification of the header table is the replacement of an existing entry, the replaced entry is the one indicated in the literal representation before any entry is removed from the header table. If the entry to be replaced is removed from the header table when performing the size adjustment, the replacement entry is inserted at the beginning of the header table.  </p>
<p id="rfc.section.3.2.3.p.4">The addition of a new entry with a size greater than the SETTINGS_MAX_BUFFER_SIZE limit causes all the entries from the header table to be dropped and the new entry not to be added to the header table. The replacement of an existing entry with a new entry with a size greater than the SETTINGS_MAX_BUFFER_SIZE has the same consequences.  </p>
<h1 id="rfc.section.3.2.4"><a href="#rfc.section.3.2.4">3.2.4.</a> <a href="#specific.use.cases" id="specific.use.cases">Specific Use Cases</a></h1>
<p id="rfc.section.3.2.4.p.1">Three occurrences of the same indexed representation, corresponding to an entry not present in the reference set, emit the associated header twice: </p>

<ul>
  <li>The first occurrence emits the header a first time and adds the corresponding entry to the reference set.  </li>
  <li>The second occurrence removes the header's entry from the reference set.  </li>
  <li>The third occurrence emits the header a second time and adds again its entry to the reference set.  </li>
</ul>

<p> </p>
<p id="rfc.section.3.2.4.p.2">The first occurrence of the indexed representation can be replaced by a literal representation creating an entry for the header.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#detailed.format" id="detailed.format">Detailed Format</a></h1>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#string.encoding" id="string.encoding">Low-level representations</a></h1>
<h1 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#integer.representation" id="integer.representation">Integer representation</a></h1>
<p id="rfc.section.4.1.1.p.1">Integers are used to represent name indexes, pair indexes or string lengths. To allow for optimized processing, an integer representation always finishes at the end of a byte.  </p>
<p id="rfc.section.4.1.1.p.2">An integer is represented in two parts: a prefix that fills the current byte and an optional list of bytes that are used if the integer value does not fit in the prefix.  The number of bits of the prefix (called N) is a parameter of the integer representation.  </p>
<p id="rfc.section.4.1.1.p.3">The N-bit prefix allows filling the current byte.  If the value is small enough (strictly less than 2^N-1), it is encoded within the N-bit prefix.  Otherwise all the bits of the prefix are set to 1 and the value is encoded using an <a href="http://en.wikipedia.org/wiki/Variable-length_quantity">unsigned variable length integer</a> representation.  </p>
<p id="rfc.section.4.1.1.p.4">The algorithm to represent an integer I is as follows: </p>

<ol>
  <li>If I &lt; 2^N - 1, encode I on N bits</li>
  <li>Else, encode 2^N - 1 on N bits and do the following steps:</li>
  <li>
    <ol>
      <li>Set I to (I - (2^N - 1)) and Q to 1</li>
      <li>While Q &gt; 0</li>
      <li>
        <ol>
          <li>Compute Q and R, quotient and remainder of I divided by 2^7</li>
          <li>If Q is strictly greater than 0, write one 1 bit; otherwise, write one 0 bit</li>
          <li>Encode R on the next 7 bits</li>
          <li>I = Q</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p> </p>
<h1 id="rfc.section.4.1.1.1"><a href="#rfc.section.4.1.1.1">4.1.1.1.</a> <a href="#integer.representation.example1" id="integer.representation.example1">Example 1: Encoding 10 using a 5-bit prefix</a></h1>
<p id="rfc.section.4.1.1.1.p.1">The value 10 is to be encoded with a 5-bit prefix.  </p>

<ul>
  <li>10 is less than 31 (= 2^5 - 1) and is represented using the 5-bit prefix.  </li>
</ul>

<p> </p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 0 | 1 | 0 | 1 | 0 |   10 stored on 5 bits
+---+---+---+---+---+---+---+---+
</pre>
<p class="figure"></p>
<h1 id="rfc.section.4.1.1.2"><a href="#rfc.section.4.1.1.2">4.1.1.2.</a> <a href="#integer.representation.example2" id="integer.representation.example2">Example 2: Encoding 1337 using a 5-bit prefix</a></h1>
<p id="rfc.section.4.1.1.2.p.1">The value I=1337 is to be encoded with a 5-bit prefix.  </p>

<ul>
  <li>1337 is greater than 31 (= 2^5 - 1).</li>
  <li>
    <ul>
      <li>The 5-bit prefix is filled with its max value (31).</li>
    </ul>
  </li>
  <li>The value to represent on next bytes is I = 1337 - (2^5 - 1) = 1306.</li>
  <li>
    <ul>
      <li>1306 = 128*10 + 26, i.e. Q=10 and R=26.</li>
      <li>Q is greater than 1, bit 8 is set to 1.</li>
      <li>The remainder R=26 is encoded on next 7 bits.</li>
      <li>I is replaced by the quotient Q=10.</li>
    </ul>
  </li>
  <li>The value to represent on next bytes is I = 10.</li>
  <li>
    <ul>
      <li>10 = 128*0 + 10, i.e. Q=0 and R=10.</li>
      <li>Q is equal to 0, bit 16 is set to 0.</li>
      <li>The remainder R=10 is encoded on next 7 bits.</li>
      <li>I is replaced by the quotient Q=0.</li>
    </ul>
  </li>
  <li>The process ends.</li>
</ul>

<p> </p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 1 | 1 | 1 | 1 | 1 |   Prefix = 31
| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |   Q&gt;=1, R=26
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |   Q=0 , R=10
+---+---+---+---+---+---+---+---+
</pre>
<p class="figure"></p>
<h1 id="rfc.section.4.1.2"><a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#string.literal.representation" id="string.literal.representation">String Literal Representation</a></h1>
<p id="rfc.section.4.1.2.p.1">Literal strings can represent header names or header values.  They are encoded in two parts: </p>

<ol>
  <li>The string length, defined as the number of bytes needed to store its UTF-8 representation, is represented as an integer with a zero bits prefix.  If the string length is strictly less than 128, it is represented as one byte.  </li>
  <li>The string value represented as a list of UTF-8 characters.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#indexed.header.representation" id="indexed.header.representation">Indexed Header Representation</a></h1>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
</pre>
<p class="figure">Indexed Header</p>
<p id="rfc.section.4.2.p.1">This representation starts with the '1' 1-bit pattern, followed by the index of the matching pair, represented as an integer with a 7-bit prefix.  </p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#literal.header.representation" id="literal.header.representation">Literal Header Representation</a></h1>
<h1 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#literal.header.without.indexing" id="literal.header.without.indexing">Literal Header without Indexing</a></h1>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 1 |    Index (5+)     |
+---+---+---+-------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre>
<p class="figure">Literal Header without Indexing - Indexed Name</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 1 |         0         |
+---+---+---+-------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre>
<p class="figure">Literal Header without Indexing - New Name</p>
<p id="rfc.section.4.3.1.p.1">This representation, which does not involve updating the header table, starts with the '011' 3-bit pattern.  </p>
<p id="rfc.section.4.3.1.p.2">If the header name matches the header name of a (name, value) pair stored in the Header Table, the index of the pair increased by one (index + 1) is represented as an integer with a 5-bit prefix.  Note that if the index is strictly below 31, one byte is used.  </p>
<p id="rfc.section.4.3.1.p.3">If the header name does not match a header name entry, the value 0 is represented on 5 bits followed by the header name, represented as a literal string.  </p>
<p id="rfc.section.4.3.1.p.4">Header name representation is followed by the header value represented as a literal string as described in <a href="#string.literal.representation">Section 4.1.2</a>.  </p>
<h1 id="rfc.section.4.3.2"><a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#literal.header.with.incremental.indexing" id="literal.header.with.incremental.indexing">Literal Header with Incremental Indexing</a></h1>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 |    Index (5+)     |
+---+---+---+-------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre>
<p class="figure">Literal Header with Incremental Indexing -                         Indexed Name</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 |         0         |
+---+---+---+-------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre>
<p class="figure">Literal Header with Incremental Indexing -                         New Name</p>
<p id="rfc.section.4.3.2.p.1">This representation starts with the '010' 3-bit pattern.  </p>
<p id="rfc.section.4.3.2.p.2">If the header name matches the header name of a (name, value) pair stored in the Header Table, the index of the pair increased by one (index + 1) is represented as an integer with a 5-bit prefix.  Note that if the index is strictly below 31, one byte is used.  </p>
<p id="rfc.section.4.3.2.p.3">If the header name does not match a header name entry, the value 0 is represented on 5 bits followed by the header name, represented as a literal string.  </p>
<p id="rfc.section.4.3.2.p.4">Header name representation is followed by the header value represented as a literal string as described in <a href="#string.literal.representation">Section 4.1.2</a>.  </p>
<h1 id="rfc.section.4.3.3"><a href="#rfc.section.4.3.3">4.3.3.</a> <a href="#literal.header.with.substitution.indexing" id="literal.header.with.substitution.indexing">Literal Header with Substitution Indexing</a></h1>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |      Index (6+)       |
+---+---+-----------------------+
|    Substituted Index (8+)     |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre>
<p class="figure">Literal Header with Substitution Indexing -                         Indexed Name</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |           0           |
+---+---+-----------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|    Substituted Index (8+)     |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</pre>
<p class="figure">Literal Header with Substitution Indexing -                         New Name</p>
<p id="rfc.section.4.3.3.p.1">This representation starts with the '00' 2-bit pattern.  </p>
<p id="rfc.section.4.3.3.p.2">If the header name matches the header name of a (name, value) pair stored in the Header Table, the index of the pair increased by one (index + 1) is represented as an integer with a 6-bit prefix.  Note that if the index is strictly below 62, one byte is used.  </p>
<p id="rfc.section.4.3.3.p.3">If the header name does not match a header name entry, the value 0 is represented on 6 bits followed by the header name, represented as a literal string.  </p>
<p id="rfc.section.4.3.3.p.4">The index of the substituted (name, value) pair is inserted after the header name representation as a 0-bit prefix integer.  </p>
<p id="rfc.section.4.3.3.p.5">The index of the substituted pair MUST correspond to a position in the header table containing a non-void entry. An index for the substituted pair that corresponds to empty position in the header table MUST be treated as an error.  </p>
<p id="rfc.section.4.3.3.p.6">This index is followed by the header value represented as a literal string as described in <a href="#string.literal.representation">Section 4.1.2</a>.  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#parameter.negotiation" id="parameter.negotiation">Parameter Negotiation</a></h1>
<p id="rfc.section.5.p.1">A few parameters can be used to accommodate client and server processing and memory requirements.  </p>

<dl>
  <dt>SETTINGS_MAX_BUFFER_SIZE:</dt>
  <dd style="margin-left: 8">Allows the sender to inform the remote endpoint of the maximum size it accepts for the header table.  <br/> The default value is 4096 bytes.  <br/> <br/> When the remote endpoint receives a SETTINGS frame containing a SETTINGS_MAX_BUFFER_SIZE setting with a value smaller than the one currently in use, it MUST send as soon as possible a HEADER frame with a stream identifier of 0x0 containing a value smaller than or equal to the received setting value.  <br/> <br/> A HEADER frame with a stream identifier of 0x0 indicates that the sender has reduced the maximum size of the header table. The new maximum size of the header table is encoded on 32-bit. The decoder MUST reduce its own header table by dropping entries from it until the size of the header table is lower than or equal to the transmitted maximum size.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#Security" id="Security">Security Considerations</a></h1>
<p id="rfc.section.6.p.1">TODO</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#IANA" id="IANA">IANA Considerations</a></h1>
<p id="rfc.section.7.p.1">This memo includes no request to IANA.</p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="SPDY">[SPDY]</b>
      </td>
      <td class="top"><a title="Twist">Belshe, M.</a> and <a title="Google">R. Peon</a>, "<a>SPDY Protocol</a>", February 2012.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> Change Log (to be removed by RFC Editor before publication</h1>
<h1 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> Since draft-ietf-httpbis-header-compression-01</h1>
<p/>

<ul>
  <li>Refactored of Header Encoding Section: split definitions and processing rule.  </li>
  <li>Backward incompatible change: Updated reference set management as per issue #214. This changes how the interaction between the reference set and eviction works. This also changes the working of the reference set in some specific cases.  </li>
  <li>Backward incompatible change: modified initial header list, as per issue #188.  </li>
  <li>Added example of 32 bytes entry structure (issue #191).  </li>
</ul>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> <a href="#initial.headers" id="initial.headers">Initial Header Tables</a></h1>
<p>
  <br/>
</p>
<h1 id="rfc.appendix.B.1"><a href="#rfc.appendix.B.1">B.1.</a> Requests</h1>
<p id="rfc.section.B.1.p.1">The following table lists the pre-defined headers that make-up the initial header table user to represent requests sent from a client to a server.  </p>
<div id="rfc.table.1"/>
<div id="initial.headers.request"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>Initial Header Table for Requests</caption>
  <thead>
    <tr>
      <th class="left">Index</th>
      <th class="left">Header Name</th>
      <th class="left">Header Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">0</td>
      <td class="left">:scheme</td>
      <td class="left">http</td>
    </tr>
    <tr>
      <td class="left">1</td>
      <td class="left">:scheme</td>
      <td class="left">https</td>
    </tr>
    <tr>
      <td class="left">2</td>
      <td class="left">:host</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">3</td>
      <td class="left">:path</td>
      <td class="left">/</td>
    </tr>
    <tr>
      <td class="left">4</td>
      <td class="left">:method</td>
      <td class="left">GET</td>
    </tr>
    <tr>
      <td class="left">5</td>
      <td class="left">accept</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">6</td>
      <td class="left">accept-charset</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">7</td>
      <td class="left">accept-encoding</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">8</td>
      <td class="left">accept-language</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">9</td>
      <td class="left">cookie</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">10</td>
      <td class="left">if-modified-since</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">11</td>
      <td class="left">user-agent</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">12</td>
      <td class="left">referer</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">13</td>
      <td class="left">authorization</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">14</td>
      <td class="left">allow</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">15</td>
      <td class="left">cache-control</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">16</td>
      <td class="left">connection</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">17</td>
      <td class="left">content-length</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">18</td>
      <td class="left">content-type</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">19</td>
      <td class="left">date</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">20</td>
      <td class="left">expect</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">21</td>
      <td class="left">from</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">22</td>
      <td class="left">if-match</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">23</td>
      <td class="left">if-none-match</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">24</td>
      <td class="left">if-range</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">25</td>
      <td class="left">if-unmodified-since</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">26</td>
      <td class="left">max-forwards</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">27</td>
      <td class="left">proxy-authorization</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">28</td>
      <td class="left">range</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">29</td>
      <td class="left">via</td>
      <td class="left"/>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.B.2"><a href="#rfc.appendix.B.2">B.2.</a> Responses</h1>
<p id="rfc.section.B.2.p.1">The following table lists the pre-defined headers that make-up the initial header table used to represent responses sent from a server to a client. The same header table is also used to represent request headers sent from a server to a client in a PUSH_PROMISE frame.  </p>
<div id="rfc.table.2"/>
<div id="initial.headers.response"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>Initial Header Table for Responses</caption>
  <thead>
    <tr>
      <th class="left">Index</th>
      <th class="left">Header Name</th>
      <th class="left">Header Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">0</td>
      <td class="left">:status</td>
      <td class="left">200</td>
    </tr>
    <tr>
      <td class="left">1</td>
      <td class="left">age</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">2</td>
      <td class="left">cache-control</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">3</td>
      <td class="left">content-length</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">4</td>
      <td class="left">content-type</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">5</td>
      <td class="left">date</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">6</td>
      <td class="left">etag</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">7</td>
      <td class="left">expires</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">8</td>
      <td class="left">last-modified</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">9</td>
      <td class="left">server</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">10</td>
      <td class="left">set-cookie</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">11</td>
      <td class="left">vary</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">12</td>
      <td class="left">via</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">13</td>
      <td class="left">access-control-allow-origin</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">14</td>
      <td class="left">accept-ranges</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">15</td>
      <td class="left">allow</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">16</td>
      <td class="left">connection</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">17</td>
      <td class="left">content-disposition</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">18</td>
      <td class="left">content-encoding</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">19</td>
      <td class="left">content-language</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">20</td>
      <td class="left">content-location</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">21</td>
      <td class="left">content-range</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">22</td>
      <td class="left">link</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">23</td>
      <td class="left">location</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">24</td>
      <td class="left">proxy-authenticate</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">25</td>
      <td class="left">refresh</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">26</td>
      <td class="left">retry-after</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">27</td>
      <td class="left">strict-transport-security</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">28</td>
      <td class="left">transfer-encoding</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">29</td>
      <td class="left">www-authenticate</td>
      <td class="left"/>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> <a href="#example" id="example">Example</a></h1>
<p id="rfc.section.C.p.1">Here is an example that illustrates different representations and how tables are updated.  </p>
<h1 id="rfc.appendix.C.1"><a href="#rfc.appendix.C.1">C.1.</a> First header set</h1>
<pre>
:path: /my-example/index.html
user-agent: my-user-agent
x-my-header: first
</pre>
<p class="figure"></p>
<pre>
0x44      (literal header with incremental indexing, name index = 3)
0x16      (header value string length = 22)
/my-example/index.html
0x4D      (literal header with incremental indexing, name index = 12)
0x0D      (header value string length = 13)
my-user-agent
0x40      (literal header with incremental indexing, new name)
0x0B      (header name string length = 11)
x-my-header
0x05      (header value string length = 5)
first
</pre>
<p class="figure"></p>
<pre>
Header table
+---------+----------------+---------------------------+
|  Index  | Header Name    | Header Value              |
+---------+----------------+---------------------------+
|    0    | :scheme        | http                      |
+---------+----------------+---------------------------+
|    1    | :scheme        | https                     |
+---------+----------------+---------------------------+
|   ...   | ...            | ...                       |
+---------+----------------+---------------------------+
|   37    | warning        |                           |
+---------+----------------+---------------------------+
|   38    | :path          | /my-example/index.html    | added header
+---------+----------------+---------------------------+
|   39    | user-agent     | my-user-agent             | added header
+---------+----------------+---------------------------+
|   40    | x-my-header    | first                     | added header
+---------+----------------+---------------------------+
</pre>
<p class="figure"></p>
<pre>
Reference Set:
:path, /my-example/index.html
user-agent, my-user-agent
x-my-header, first
</pre>
<p class="figure"></p>
<p id="rfc.section.C.1.p.1">The first header set to represent is the following: </p>
<h1 id="rfc.appendix.C.2"><a href="#rfc.appendix.C.2">C.2.</a> Second header set</h1>
<pre>
:path: /my-example/resources/script.js
user-agent: my-user-agent
x-my-header: second
</pre>
<p class="figure"></p>
<pre>
0xa6       (indexed header, index = 38: removal from reference set)
0xa8       (indexed header, index = 40: removal from reference set)
0x04       (literal header, substitution indexing, name index = 3)
0x26       (replaced entry index = 38)
0x1f       (header value string length = 31)
/my-example/resources/script.js
0x5f 0x0a  (literal header, incremental indexing, name index = 40)
0x06       (header value string length = 6)
second
</pre>
<p class="figure"></p>
<pre>
Header table
+---------+----------------+---------------------------+
|  Index  | Header Name    | Header Value              |
+---------+----------------+---------------------------+
|    0    | :scheme        | http                      |
+---------+----------------+---------------------------+
|    1    | :scheme        | https                     |
+---------+----------------+---------------------------+
|   ...   | ...            | ...                       |
+---------+----------------+---------------------------+
|   37    | warning        |                           |
+---------+----------------+---------------------------+
|   38    | :path          | /my-example/resources/    | replaced
|         |                |     script.js             | header
+---------+----------------+---------------------------+
|   39    | user-agent     | my-user-agent             |
+---------+----------------+---------------------------+
|   40    | x-my-header    | first                     |
+---------+----------------+---------------------------+
|   41    | x-my-header    | second                    | added header
+---------+----------------+---------------------------+
</pre>
<p class="figure"></p>
<pre>
Reference Set:
:path, /my-example/resources/script.js
user-agent, my-user-agent
x-my-header, second
</pre>
<p class="figure"></p>
<p id="rfc.section.C.2.p.1">The second header set to represent is the following: </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Roberto Peon</span> 
	  <span class="n hidden">
		<span class="family-name">Peon</span>
	  </span>
	</span>
	<span class="org vcardline">Google, Inc</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: fenix@google.com</span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Hervé Ruellan</span> 
	  <span class="n hidden">
		<span class="family-name">Ruellan</span>
	  </span>
	</span>
	<span class="org vcardline">Canon CRF</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: herve.ruellan@crf.canon.fr</span>

  </address>
</div>

</body>
</html>